{"version":3,"sources":["react-dom-unstable-native-dependencies.development.js"],"names":[],"mappings":"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","file":"react-dom-unstable-native-dependencies.development-compiled.js","sourcesContent":["/** @license React v16.2.0\n * react-dom-unstable-native-dependencies.development.js\n *\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar ReactDOM = require('react-dom');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\nvar _assign = require('object-assign');\nvar emptyFunction = require('fbjs/lib/emptyFunction');\n\n/**\n * WARNING: DO NOT manually require this module.\n * This is a replacement for `invariant(...)` used by the error code system\n * and will _only_ be required by the corresponding babel pass.\n * It always throws.\n */\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // untintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    \n  }\n}\n\nvar getFiberCurrentPropsFromNode = null;\nvar getInstanceFromNode = null;\nvar getNodeFromInstance = null;\n\nvar injection = {\n  injectComponentTree: function (Injected) {\n    getFiberCurrentPropsFromNode = Injected.getFiberCurrentPropsFromNode;\n    getInstanceFromNode = Injected.getInstanceFromNode;\n    getNodeFromInstance = Injected.getNodeFromInstance;\n\n    {\n      warning(getNodeFromInstance && getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.');\n    }\n  }\n};\n\nfunction isEndish(topLevelType) {\n  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';\n}\n\nfunction isMoveish(topLevelType) {\n  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';\n}\nfunction isStartish(topLevelType) {\n  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';\n}\n\nvar validateEventDispatches;\n{\n  validateEventDispatches = function (event) {\n    var dispatchListeners = event._dispatchListeners;\n    var dispatchInstances = event._dispatchInstances;\n\n    var listenersIsArr = Array.isArray(dispatchListeners);\n    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;\n\n    var instancesIsArr = Array.isArray(dispatchInstances);\n    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;\n\n    warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.');\n  };\n}\n\n/**\n * Standard/simple iteration through an event's collected dispatches.\n */\n\n\n/**\n * Standard/simple iteration through an event's collected dispatches, but stops\n * at the first dispatch execution returning true, and returns that id.\n *\n * @return {?string} id of the first dispatch execution who's listener returns\n * true, or null if no listener returned true.\n */\nfunction executeDispatchesInOrderStopAtTrueImpl(event) {\n  var dispatchListeners = event._dispatchListeners;\n  var dispatchInstances = event._dispatchInstances;\n  {\n    validateEventDispatches(event);\n  }\n  if (Array.isArray(dispatchListeners)) {\n    for (var i = 0; i < dispatchListeners.length; i++) {\n      if (event.isPropagationStopped()) {\n        break;\n      }\n      // Listeners and Instances are two parallel arrays that are always in sync.\n      if (dispatchListeners[i](event, dispatchInstances[i])) {\n        return dispatchInstances[i];\n      }\n    }\n  } else if (dispatchListeners) {\n    if (dispatchListeners(event, dispatchInstances)) {\n      return dispatchInstances;\n    }\n  }\n  return null;\n}\n\n/**\n * @see executeDispatchesInOrderStopAtTrueImpl\n */\nfunction executeDispatchesInOrderStopAtTrue(event) {\n  var ret = executeDispatchesInOrderStopAtTrueImpl(event);\n  event._dispatchInstances = null;\n  event._dispatchListeners = null;\n  return ret;\n}\n\n/**\n * Execution of a \"direct\" dispatch - there must be at most one dispatch\n * accumulated on the event or it is considered an error. It doesn't really make\n * sense for an event with multiple dispatches (bubbled) to keep track of the\n * return values at each dispatch execution, but it does tend to make sense when\n * dealing with \"direct\" dispatches.\n *\n * @return {*} The return value of executing the single dispatch.\n */\nfunction executeDirectDispatch(event) {\n  {\n    validateEventDispatches(event);\n  }\n  var dispatchListener = event._dispatchListeners;\n  var dispatchInstance = event._dispatchInstances;\n  !!Array.isArray(dispatchListener) ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : void 0;\n  event.currentTarget = dispatchListener ? getNodeFromInstance(dispatchInstance) : null;\n  var res = dispatchListener ? dispatchListener(event) : null;\n  event.currentTarget = null;\n  event._dispatchListeners = null;\n  event._dispatchInstances = null;\n  return res;\n}\n\n/**\n * @param {SyntheticEvent} event\n * @return {boolean} True iff number of dispatches accumulated is greater than 0.\n */\nfunction hasDispatches(event) {\n  return !!event._dispatchListeners;\n}\n\n// Before we know whether it is functional or class\n\n\n // Root of a host tree. Could be nested inside another node.\n // A subtree. Could be an entry point to a different renderer.\nvar HostComponent = 5;\n\nfunction getParent(inst) {\n  do {\n    inst = inst['return'];\n    // TODO: If this is a HostRoot we might want to bail out.\n    // That is depending on if we want nested subtrees (layers) to bubble\n    // events to their parent. We could also go through parentNode on the\n    // host node but that wouldn't work for React Native and doesn't let us\n    // do the portal feature.\n  } while (inst && inst.tag !== HostComponent);\n  if (inst) {\n    return inst;\n  }\n  return null;\n}\n\n/**\n * Return the lowest common ancestor of A and B, or null if they are in\n * different trees.\n */\nfunction getLowestCommonAncestor(instA, instB) {\n  var depthA = 0;\n  for (var tempA = instA; tempA; tempA = getParent(tempA)) {\n    depthA++;\n  }\n  var depthB = 0;\n  for (var tempB = instB; tempB; tempB = getParent(tempB)) {\n    depthB++;\n  }\n\n  // If A is deeper, crawl up.\n  while (depthA - depthB > 0) {\n    instA = getParent(instA);\n    depthA--;\n  }\n\n  // If B is deeper, crawl up.\n  while (depthB - depthA > 0) {\n    instB = getParent(instB);\n    depthB--;\n  }\n\n  // Walk in lockstep until we find a match.\n  var depth = depthA;\n  while (depth--) {\n    if (instA === instB || instA === instB.alternate) {\n      return instA;\n    }\n    instA = getParent(instA);\n    instB = getParent(instB);\n  }\n  return null;\n}\n\n/**\n * Return if A is an ancestor of B.\n */\nfunction isAncestor(instA, instB) {\n  while (instB) {\n    if (instA === instB || instA === instB.alternate) {\n      return true;\n    }\n    instB = getParent(instB);\n  }\n  return false;\n}\n\n/**\n * Return the parent instance of the passed-in instance.\n */\nfunction getParentInstance(inst) {\n  return getParent(inst);\n}\n\n/**\n * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n */\nfunction traverseTwoPhase(inst, fn, arg) {\n  var path = [];\n  while (inst) {\n    path.push(inst);\n    inst = getParent(inst);\n  }\n  var i;\n  for (i = path.length; i-- > 0;) {\n    fn(path[i], 'captured', arg);\n  }\n  for (i = 0; i < path.length; i++) {\n    fn(path[i], 'bubbled', arg);\n  }\n}\n\n/**\n * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n * should would receive a `mouseEnter` or `mouseLeave` event.\n *\n * Does not invoke the callback on the nearest common ancestor because nothing\n * \"entered\" or \"left\" that element.\n */\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\n\n/**\n * Ordered list of injected plugins.\n */\n\n\n/**\n * Mapping from event name to dispatch config\n */\n\n\n/**\n * Mapping from registration name to plugin module\n */\n\n\n/**\n * Mapping from registration name to event name\n */\n\n\n/**\n * Mapping from lowercase registration names to the properly cased version,\n * used to warn in the case of missing event handlers. Available\n * only in true.\n * @type {Object}\n */\n\n// Trust the developer to only use possibleRegistrationNames in true\n\n/**\n * Injects an ordering of plugins (by plugin name). This allows the ordering\n * to be decoupled from injection of the actual plugins so that ordering is\n * always deterministic regardless of packaging, on-the-fly injection, etc.\n *\n * @param {array} InjectedEventPluginOrder\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginOrder}\n */\n\n\n/**\n * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n * in the ordering injected by `injectEventPluginOrder`.\n *\n * Plugins can be injected as part of page initialization or on-the-fly.\n *\n * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n * @internal\n * @see {EventPluginHub.injection.injectEventPluginsByName}\n */\n\n/**\n * Accumulates items that must not be null or undefined into the first one. This\n * is used to conserve memory by avoiding array allocations, and thus sacrifices\n * API cleanness. Since `current` can be null before being passed in and not\n * null after this function, make sure to assign it back to `current`:\n *\n * `a = accumulateInto(a, b);`\n *\n * This API should be sparingly used. Try `accumulate` for something cleaner.\n *\n * @return {*|array<*>} An accumulation of items.\n */\n\nfunction accumulateInto(current, next) {\n  !(next != null) ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    if (Array.isArray(next)) {\n      current.push.apply(current, next);\n      return current;\n    }\n    current.push(next);\n    return current;\n  }\n\n  if (Array.isArray(next)) {\n    // A bit too dangerous to mutate `next`.\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * @param {array} arr an \"accumulation\" of items which is either an Array or\n * a single item. Useful when paired with the `accumulate` module. This is a\n * simple utility that allows us to reason about a collection of items, but\n * handling the case when there is exactly one item (and we do not need to\n * allocate an array).\n * @param {function} cb Callback invoked with each element or a collection.\n * @param {?} [scope] Scope used as `this` in a callback.\n */\nfunction forEachAccumulated(arr, cb, scope) {\n  if (Array.isArray(arr)) {\n    arr.forEach(cb, scope);\n  } else if (arr) {\n    cb.call(scope, arr);\n  }\n}\n\nfunction isInteractive(tag) {\n  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';\n}\n\nfunction shouldPreventMouseEvent(name, type, props) {\n  switch (name) {\n    case 'onClick':\n    case 'onClickCapture':\n    case 'onDoubleClick':\n    case 'onDoubleClickCapture':\n    case 'onMouseDown':\n    case 'onMouseDownCapture':\n    case 'onMouseMove':\n    case 'onMouseMoveCapture':\n    case 'onMouseUp':\n    case 'onMouseUpCapture':\n      return !!(props.disabled && isInteractive(type));\n    default:\n      return false;\n  }\n}\n\n/**\n * This is a unified interface for event plugins to be installed and configured.\n *\n * Event plugins can implement the following properties:\n *\n *   `extractEvents` {function(string, DOMEventTarget, string, object): *}\n *     Required. When a top-level event is fired, this method is expected to\n *     extract synthetic events that will in turn be queued and dispatched.\n *\n *   `eventTypes` {object}\n *     Optional, plugins that fire events must publish a mapping of registration\n *     names that are used to register listeners. Values of this mapping must\n *     be objects that contain `registrationName` or `phasedRegistrationNames`.\n *\n *   `executeDispatch` {function(object, function, string)}\n *     Optional, allows plugins to override how an event gets dispatched. By\n *     default, the listener is simply invoked.\n *\n * Each plugin that is injected into `EventsPluginHub` is immediately operable.\n *\n * @public\n */\n\n/**\n * Methods for injecting dependencies.\n */\n\n\n/**\n * @param {object} inst The instance, which is the source of events.\n * @param {string} registrationName Name of listener (e.g. `onClick`).\n * @return {?function} The stored callback.\n */\nfunction getListener(inst, registrationName) {\n  var listener;\n\n  // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not\n  // live here; needs to be moved to a better place soon\n  var stateNode = inst.stateNode;\n  if (!stateNode) {\n    // Work in progress (ex: onload events in incremental mode).\n    return null;\n  }\n  var props = getFiberCurrentPropsFromNode(stateNode);\n  if (!props) {\n    // Work in progress.\n    return null;\n  }\n  listener = props[registrationName];\n  if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n    return null;\n  }\n  !(!listener || typeof listener === 'function') ? invariant(false, 'Expected `%s` listener to be a function, instead got a value of `%s` type.', registrationName, typeof listener) : void 0;\n  return listener;\n}\n\n/**\n * Allows registered plugins an opportunity to extract events from top-level\n * native browser events.\n *\n * @return {*} An accumulation of synthetic events.\n * @internal\n */\n\n\n/**\n * Enqueues a synthetic event that should be dispatched when\n * `processEventQueue` is invoked.\n *\n * @param {*} events An accumulation of synthetic events.\n * @internal\n */\n\n\n/**\n * Dispatches all synthetic events on the event queue.\n *\n * @internal\n */\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(inst, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(inst, registrationName);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing even a\n * single one.\n */\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(inst, phase, event) {\n  {\n    warning(inst, 'Dispatching inst must not be null');\n  }\n  var listener = listenerAtPhase(inst, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    var targetInst = event._targetInst;\n    var parentInst = targetInst ? getParentInstance(targetInst) : null;\n    traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(inst, ignoredDirection, event) {\n  if (inst && event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(inst, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event._targetInst, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\n\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/* eslint valid-typeof: 0 */\n\nvar didWarnForAddedNewProperty = false;\nvar isProxySupported = typeof Proxy === 'function';\nvar EVENT_POOL_SIZE = 10;\n\nvar shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];\n\n/**\n * @interface Event\n * @see http://www.w3.org/TR/DOM-Level-3-Events/\n */\nvar EventInterface = {\n  type: null,\n  target: null,\n  // currentTarget is set when dispatching; no use in copying it here\n  currentTarget: emptyFunction.thatReturnsNull,\n  eventPhase: null,\n  bubbles: null,\n  cancelable: null,\n  timeStamp: function (event) {\n    return event.timeStamp || Date.now();\n  },\n  defaultPrevented: null,\n  isTrusted: null\n};\n\n/**\n * Synthetic events are dispatched by event plugins, typically in response to a\n * top-level event delegation handler.\n *\n * These systems should generally use pooling to reduce the frequency of garbage\n * collection. The system should check `isPersistent` to determine whether the\n * event should be released into the pool after being dispatched. Users that\n * need a persisted event should invoke `persist`.\n *\n * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n * normalizing browser quirks. Subclasses do not necessarily have to implement a\n * DOM interface; custom application-specific events can also subclass this.\n *\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {*} targetInst Marker identifying the event target.\n * @param {object} nativeEvent Native browser event.\n * @param {DOMEventTarget} nativeEventTarget Target node.\n */\nfunction SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {\n  {\n    // these have a getter/setter for warnings\n    delete this.nativeEvent;\n    delete this.preventDefault;\n    delete this.stopPropagation;\n  }\n\n  this.dispatchConfig = dispatchConfig;\n  this._targetInst = targetInst;\n  this.nativeEvent = nativeEvent;\n\n  var Interface = this.constructor.Interface;\n  for (var propName in Interface) {\n    if (!Interface.hasOwnProperty(propName)) {\n      continue;\n    }\n    {\n      delete this[propName]; // this has a getter/setter for warnings\n    }\n    var normalize = Interface[propName];\n    if (normalize) {\n      this[propName] = normalize(nativeEvent);\n    } else {\n      if (propName === 'target') {\n        this.target = nativeEventTarget;\n      } else {\n        this[propName] = nativeEvent[propName];\n      }\n    }\n  }\n\n  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n  if (defaultPrevented) {\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  } else {\n    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;\n  }\n  this.isPropagationStopped = emptyFunction.thatReturnsFalse;\n  return this;\n}\n\n_assign(SyntheticEvent.prototype, {\n  preventDefault: function () {\n    this.defaultPrevented = true;\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.preventDefault) {\n      event.preventDefault();\n    } else if (typeof event.returnValue !== 'unknown') {\n      event.returnValue = false;\n    }\n    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;\n  },\n\n  stopPropagation: function () {\n    var event = this.nativeEvent;\n    if (!event) {\n      return;\n    }\n\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    } else if (typeof event.cancelBubble !== 'unknown') {\n      // The ChangeEventPlugin registers a \"propertychange\" event for\n      // IE. This event does not support bubbling or cancelling, and\n      // any references to cancelBubble throw \"Member not found\".  A\n      // typeof check of \"unknown\" circumvents this issue (and is also\n      // IE specific).\n      event.cancelBubble = true;\n    }\n\n    this.isPropagationStopped = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * We release all dispatched `SyntheticEvent`s after each event loop, adding\n   * them back into the pool. This allows a way to hold onto a reference that\n   * won't be added back into the pool.\n   */\n  persist: function () {\n    this.isPersistent = emptyFunction.thatReturnsTrue;\n  },\n\n  /**\n   * Checks if this event should be released back into the pool.\n   *\n   * @return {boolean} True if this should not be released, false otherwise.\n   */\n  isPersistent: emptyFunction.thatReturnsFalse,\n\n  /**\n   * `PooledClass` looks for `destructor` on each instance it releases.\n   */\n  destructor: function () {\n    var Interface = this.constructor.Interface;\n    for (var propName in Interface) {\n      {\n        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));\n      }\n    }\n    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {\n      this[shouldBeReleasedProperties[i]] = null;\n    }\n    {\n      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));\n      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));\n      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));\n    }\n  }\n});\n\nSyntheticEvent.Interface = EventInterface;\n\n/**\n * Helper to reduce boilerplate when creating subclasses.\n *\n * @param {function} Class\n * @param {?object} Interface\n */\nSyntheticEvent.augmentClass = function (Class, Interface) {\n  var Super = this;\n\n  var E = function () {};\n  E.prototype = Super.prototype;\n  var prototype = new E();\n\n  _assign(prototype, Class.prototype);\n  Class.prototype = prototype;\n  Class.prototype.constructor = Class;\n\n  Class.Interface = _assign({}, Super.Interface, Interface);\n  Class.augmentClass = Super.augmentClass;\n  addEventPoolingTo(Class);\n};\n\n/** Proxying after everything set on SyntheticEvent\n * to resolve Proxy issue on some WebKit browsers\n * in which some Event properties are set to undefined (GH#10010)\n */\n{\n  if (isProxySupported) {\n    /*eslint-disable no-func-assign */\n    SyntheticEvent = new Proxy(SyntheticEvent, {\n      construct: function (target, args) {\n        return this.apply(target, Object.create(target.prototype), args);\n      },\n      apply: function (constructor, that, args) {\n        return new Proxy(constructor.apply(that, args), {\n          set: function (target, prop, value) {\n            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {\n              warning(didWarnForAddedNewProperty || target.isPersistent(), \"This synthetic event is reused for performance reasons. If you're \" + \"seeing this, you're adding a new property in the synthetic event object. \" + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.');\n              didWarnForAddedNewProperty = true;\n            }\n            target[prop] = value;\n            return true;\n          }\n        });\n      }\n    });\n    /*eslint-enable no-func-assign */\n  }\n}\n\naddEventPoolingTo(SyntheticEvent);\n\n/**\n * Helper to nullify syntheticEvent instance properties when destructing\n *\n * @param {String} propName\n * @param {?object} getVal\n * @return {object} defineProperty object\n */\nfunction getPooledWarningPropertyDefinition(propName, getVal) {\n  var isFunction = typeof getVal === 'function';\n  return {\n    configurable: true,\n    set: set,\n    get: get\n  };\n\n  function set(val) {\n    var action = isFunction ? 'setting the method' : 'setting the property';\n    warn(action, 'This is effectively a no-op');\n    return val;\n  }\n\n  function get() {\n    var action = isFunction ? 'accessing the method' : 'accessing the property';\n    var result = isFunction ? 'This is a no-op function' : 'This is set to null';\n    warn(action, result);\n    return getVal;\n  }\n\n  function warn(action, result) {\n    var warningCondition = false;\n    warning(warningCondition, \"This synthetic event is reused for performance reasons. If you're seeing this, \" + \"you're %s `%s` on a released/nullified synthetic event. %s. \" + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result);\n  }\n}\n\nfunction getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) {\n  var EventConstructor = this;\n  if (EventConstructor.eventPool.length) {\n    var instance = EventConstructor.eventPool.pop();\n    EventConstructor.call(instance, dispatchConfig, targetInst, nativeEvent, nativeInst);\n    return instance;\n  }\n  return new EventConstructor(dispatchConfig, targetInst, nativeEvent, nativeInst);\n}\n\nfunction releasePooledEvent(event) {\n  var EventConstructor = this;\n  !(event instanceof EventConstructor) ? invariant(false, 'Trying to release an event instance  into a pool of a different type.') : void 0;\n  event.destructor();\n  if (EventConstructor.eventPool.length < EVENT_POOL_SIZE) {\n    EventConstructor.eventPool.push(event);\n  }\n}\n\nfunction addEventPoolingTo(EventConstructor) {\n  EventConstructor.eventPool = [];\n  EventConstructor.getPooled = getPooledEvent;\n  EventConstructor.release = releasePooledEvent;\n}\n\nvar SyntheticEvent$1 = SyntheticEvent;\n\n/**\n * `touchHistory` isn't actually on the native event, but putting it in the\n * interface will ensure that it is cleaned up when pooled/destroyed. The\n * `ResponderEventPlugin` will populate it appropriately.\n */\nvar ResponderEventInterface = {\n  touchHistory: function (nativeEvent) {\n    return null; // Actually doesn't even look at the native event.\n  }\n};\n\n/**\n * @param {object} dispatchConfig Configuration used to dispatch this event.\n * @param {string} dispatchMarker Marker identifying the event target.\n * @param {object} nativeEvent Native event.\n * @extends {SyntheticEvent}\n */\nfunction ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {\n  return SyntheticEvent$1.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);\n}\n\nSyntheticEvent$1.augmentClass(ResponderSyntheticEvent, ResponderEventInterface);\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\". Let both work for now while we iron it out\n  // TODO (evv): rename timeStamp to timestamp in internal code\n  return touch.timeStamp || touch.timestamp;\n}\n\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  !(identifier != null) ? invariant(false, 'Touch object is missing identifier.') : void 0;\n  {\n    warning(identifier <= MAX_TOUCH_BANK, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n  }\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error('Cannot record touch move without a touch start.\\n' + 'Touch Move: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.error('Cannot record touch end without a touch start.\\n' + 'Touch End: %s\\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function (topLevelType, nativeEvent) {\n    if (isMoveish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if (isStartish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if (isEndish(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n        {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n          warning(activeRecord != null && activeRecord.touchActive, 'Cannot find single active touch.');\n        }\n      }\n    }\n  },\n\n\n  touchHistory: touchHistory\n};\n\n/**\n * Accumulates items that must not be null or undefined.\n *\n * This is used to conserve memory by avoiding array allocations.\n *\n * @return {*|array<*>} An accumulation of items.\n */\nfunction accumulate(current, next) {\n  !(next != null) ? invariant(false, 'accumulate(...): Accumulated items must be not be null or undefined.') : void 0;\n\n  if (current == null) {\n    return next;\n  }\n\n  // Both are not empty. Warning: Never call x.concat(y) when you are not\n  // certain that x is an Array (x could be a string with concat method).\n  if (Array.isArray(current)) {\n    return current.concat(next);\n  }\n\n  if (Array.isArray(next)) {\n    return [current].concat(next);\n  }\n\n  return [current, next];\n}\n\n/**\n * Instance of element that should respond to touch/move types of interactions,\n * as indicated explicitly by relevant callbacks.\n */\nvar responderInst = null;\n\n/**\n * Count of current touches. A textInput should become responder iff the\n * selection changes while there is a touch on the screen.\n */\nvar trackedTouchCount = 0;\n\n/**\n * Last reported number of active touches.\n */\nvar previousActiveTouches = 0;\n\nvar changeResponder = function (nextResponderInst, blockHostResponder) {\n  var oldResponderInst = responderInst;\n  responderInst = nextResponderInst;\n  if (ResponderEventPlugin.GlobalResponderHandler !== null) {\n    ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);\n  }\n};\n\nvar eventTypes = {\n  /**\n   * On a `touchStart`/`mouseDown`, is it desired that this element become the\n   * responder?\n   */\n  startShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onStartShouldSetResponder',\n      captured: 'onStartShouldSetResponderCapture'\n    }\n  },\n\n  /**\n   * On a `scroll`, is it desired that this element become the responder? This\n   * is usually not needed, but should be used to retroactively infer that a\n   * `touchStart` had occurred during momentum scroll. During a momentum scroll,\n   * a touch start will be immediately followed by a scroll event if the view is\n   * currently scrolling.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  scrollShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onScrollShouldSetResponder',\n      captured: 'onScrollShouldSetResponderCapture'\n    }\n  },\n\n  /**\n   * On text selection change, should this element become the responder? This\n   * is needed for text inputs or other views with native selection, so the\n   * JS view can claim the responder.\n   *\n   * TODO: This shouldn't bubble.\n   */\n  selectionChangeShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onSelectionChangeShouldSetResponder',\n      captured: 'onSelectionChangeShouldSetResponderCapture'\n    }\n  },\n\n  /**\n   * On a `touchMove`/`mouseMove`, is it desired that this element become the\n   * responder?\n   */\n  moveShouldSetResponder: {\n    phasedRegistrationNames: {\n      bubbled: 'onMoveShouldSetResponder',\n      captured: 'onMoveShouldSetResponderCapture'\n    }\n  },\n\n  /**\n   * Direct responder events dispatched directly to responder. Do not bubble.\n   */\n  responderStart: { registrationName: 'onResponderStart' },\n  responderMove: { registrationName: 'onResponderMove' },\n  responderEnd: { registrationName: 'onResponderEnd' },\n  responderRelease: { registrationName: 'onResponderRelease' },\n  responderTerminationRequest: {\n    registrationName: 'onResponderTerminationRequest'\n  },\n  responderGrant: { registrationName: 'onResponderGrant' },\n  responderReject: { registrationName: 'onResponderReject' },\n  responderTerminate: { registrationName: 'onResponderTerminate' }\n};\n\n/**\n *\n * Responder System:\n * ----------------\n *\n * - A global, solitary \"interaction lock\" on a view.\n * - If a node becomes the responder, it should convey visual feedback\n *   immediately to indicate so, either by highlighting or moving accordingly.\n * - To be the responder means, that touches are exclusively important to that\n *   responder view, and no other view.\n * - While touches are still occurring, the responder lock can be transferred to\n *   a new view, but only to increasingly \"higher\" views (meaning ancestors of\n *   the current responder).\n *\n * Responder being granted:\n * ------------------------\n *\n * - Touch starts, moves, and scrolls can cause an ID to become the responder.\n * - We capture/bubble `startShouldSetResponder`/`moveShouldSetResponder` to\n *   the \"appropriate place\".\n * - If nothing is currently the responder, the \"appropriate place\" is the\n *   initiating event's `targetID`.\n * - If something *is* already the responder, the \"appropriate place\" is the\n *   first common ancestor of the event target and the current `responderInst`.\n * - Some negotiation happens: See the timing diagram below.\n * - Scrolled views automatically become responder. The reasoning is that a\n *   platform scroll view that isn't built on top of the responder system has\n *   began scrolling, and the active responder must now be notified that the\n *   interaction is no longer locked to it - the system has taken over.\n *\n * - Responder being released:\n *   As soon as no more touches that *started* inside of descendants of the\n *   *current* responderInst, an `onResponderRelease` event is dispatched to the\n *   current responder, and the responder lock is released.\n *\n * TODO:\n * - on \"end\", a callback hook for `onResponderEndShouldRemainResponder` that\n *   determines if the responder lock should remain.\n * - If a view shouldn't \"remain\" the responder, any active touches should by\n *   default be considered \"dead\" and do not influence future negotiations or\n *   bubble paths. It should be as if those touches do not exist.\n * -- For multitouch: Usually a translate-z will choose to \"remain\" responder\n *  after one out of many touches ended. For translate-y, usually the view\n *  doesn't wish to \"remain\" responder after one of many touches end.\n * - Consider building this on top of a `stopPropagation` model similar to\n *   `W3C` events.\n * - Ensure that `onResponderTerminate` is called on touch cancels, whether or\n *   not `onResponderTerminationRequest` returns `true` or `false`.\n *\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchStart|           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->|onResponderStart (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->|onResponderMove (cur)   |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderRejec|\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n/**\n * A note about event ordering in the `EventPluginHub`.\n *\n * Suppose plugins are injected in the following order:\n *\n * `[R, S, C]`\n *\n * To help illustrate the example, assume `S` is `SimpleEventPlugin` (for\n * `onClick` etc) and `R` is `ResponderEventPlugin`.\n *\n * \"Deferred-Dispatched Events\":\n *\n * - The current event plugin system will traverse the list of injected plugins,\n *   in order, and extract events by collecting the plugin's return value of\n *   `extractEvents()`.\n * - These events that are returned from `extractEvents` are \"deferred\n *   dispatched events\".\n * - When returned from `extractEvents`, deferred-dispatched events contain an\n *   \"accumulation\" of deferred dispatches.\n * - These deferred dispatches are accumulated/collected before they are\n *   returned, but processed at a later time by the `EventPluginHub` (hence the\n *   name deferred).\n *\n * In the process of returning their deferred-dispatched events, event plugins\n * themselves can dispatch events on-demand without returning them from\n * `extractEvents`. Plugins might want to do this, so that they can use event\n * dispatching as a tool that helps them decide which events should be extracted\n * in the first place.\n *\n * \"On-Demand-Dispatched Events\":\n *\n * - On-demand-dispatched events are not returned from `extractEvents`.\n * - On-demand-dispatched events are dispatched during the process of returning\n *   the deferred-dispatched events.\n * - They should not have side effects.\n * - They should be avoided, and/or eventually be replaced with another\n *   abstraction that allows event plugins to perform multiple \"rounds\" of event\n *   extraction.\n *\n * Therefore, the sequence of event dispatches becomes:\n *\n * - `R`s on-demand events (if any)   (dispatched by `R` on-demand)\n * - `S`s on-demand events (if any)   (dispatched by `S` on-demand)\n * - `C`s on-demand events (if any)   (dispatched by `C` on-demand)\n * - `R`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `S`s extracted events (if any)   (dispatched by `EventPluginHub`)\n * - `C`s extracted events (if any)   (dispatched by `EventPluginHub`)\n *\n * In the case of `ResponderEventPlugin`: If the `startShouldSetResponder`\n * on-demand dispatch returns `true` (and some other details are satisfied) the\n * `onResponderGrant` deferred dispatched event is returned from\n * `extractEvents`. The sequence of dispatch executions in this case\n * will appear as follows:\n *\n * - `startShouldSetResponder` (`ResponderEventPlugin` dispatches on-demand)\n * - `touchStartCapture`       (`EventPluginHub` dispatches as usual)\n * - `touchStart`              (`EventPluginHub` dispatches as usual)\n * - `responderGrant/Reject`   (`EventPluginHub` dispatches as usual)\n */\n\nfunction setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n  var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === 'topSelectionChange' ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;\n\n  // TODO: stop one short of the current responder.\n  var bubbleShouldSetFrom = !responderInst ? targetInst : getLowestCommonAncestor(responderInst, targetInst);\n\n  // When capturing/bubbling the \"shouldSet\" event, we want to skip the target\n  // (deepest ID) if it happens to be the current responder. The reasoning:\n  // It's strange to get an `onMoveShouldSetResponder` when you're *already*\n  // the responder.\n  var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;\n  var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);\n  shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n  if (skipOverBubbleShouldSetFrom) {\n    accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);\n  } else {\n    accumulateTwoPhaseDispatches(shouldSetEvent);\n  }\n  var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);\n  if (!shouldSetEvent.isPersistent()) {\n    shouldSetEvent.constructor.release(shouldSetEvent);\n  }\n\n  if (!wantsResponderInst || wantsResponderInst === responderInst) {\n    return null;\n  }\n  var extracted;\n  var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);\n  grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n\n  accumulateDirectDispatches(grantEvent);\n  var blockHostResponder = executeDirectDispatch(grantEvent) === true;\n  if (responderInst) {\n    var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);\n    terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n    accumulateDirectDispatches(terminationRequestEvent);\n    var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);\n    if (!terminationRequestEvent.isPersistent()) {\n      terminationRequestEvent.constructor.release(terminationRequestEvent);\n    }\n\n    if (shouldSwitch) {\n      var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);\n      terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(terminateEvent);\n      extracted = accumulate(extracted, [grantEvent, terminateEvent]);\n      changeResponder(wantsResponderInst, blockHostResponder);\n    } else {\n      var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);\n      rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(rejectEvent);\n      extracted = accumulate(extracted, rejectEvent);\n    }\n  } else {\n    extracted = accumulate(extracted, grantEvent);\n    changeResponder(wantsResponderInst, blockHostResponder);\n  }\n  return extracted;\n}\n\n/**\n * A transfer is a negotiation between a currently set responder and the next\n * element to claim responder status. Any start event could trigger a transfer\n * of responderInst. Any move event could trigger a transfer.\n *\n * @param {string} topLevelType Record from `BrowserEventConstants`.\n * @return {boolean} True if a transfer of responder could possibly occur.\n */\nfunction canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {\n  return topLevelInst && (\n  // responderIgnoreScroll: We are trying to migrate away from specifically\n  // tracking native scroll events here and responderIgnoreScroll indicates we\n  // will send topTouchCancel to handle canceling touch events instead\n  topLevelType === 'topScroll' && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === 'topSelectionChange' || isStartish(topLevelType) || isMoveish(topLevelType));\n}\n\n/**\n * Returns whether or not this touch end event makes it such that there are no\n * longer any touches that started inside of the current `responderInst`.\n *\n * @param {NativeEvent} nativeEvent Native touch end event.\n * @return {boolean} Whether or not this touch end event ends the responder.\n */\nfunction noResponderTouches(nativeEvent) {\n  var touches = nativeEvent.touches;\n  if (!touches || touches.length === 0) {\n    return true;\n  }\n  for (var i = 0; i < touches.length; i++) {\n    var activeTouch = touches[i];\n    var target = activeTouch.target;\n    if (target !== null && target !== undefined && target !== 0) {\n      // Is the original touch location inside of the current responder?\n      var targetInst = getInstanceFromNode(target);\n      if (isAncestor(responderInst, targetInst)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nvar ResponderEventPlugin = {\n  /* For unit testing only */\n  _getResponder: function () {\n    return responderInst;\n  },\n\n  eventTypes: eventTypes,\n\n  /**\n   * We must be resilient to `targetInst` being `null` on `touchMove` or\n   * `touchEnd`. On certain platforms, this means that a native scroll has\n   * assumed control and the original touch targets are destroyed.\n   */\n  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {\n    if (isStartish(topLevelType)) {\n      trackedTouchCount += 1;\n    } else if (isEndish(topLevelType)) {\n      if (trackedTouchCount >= 0) {\n        trackedTouchCount -= 1;\n      } else {\n        console.error('Ended a touch event which was not counted in `trackedTouchCount`.');\n        return null;\n      }\n    }\n\n    ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);\n\n    var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;\n    // Responder may or may not have transferred on a new touch start/move.\n    // Regardless, whoever is the responder after any potential transfer, we\n    // direct all touch start/move/ends to them in the form of\n    // `onResponderMove/Start/End`. These will be called for *every* additional\n    // finger that move/start/end, dispatched directly to whoever is the\n    // current responder at that moment, until the responder is \"released\".\n    //\n    // These multiple individual change touch events are are always bookended\n    // by `onResponderGrant`, and one of\n    // (`onResponderRelease/onResponderTerminate`).\n    var isResponderTouchStart = responderInst && isStartish(topLevelType);\n    var isResponderTouchMove = responderInst && isMoveish(topLevelType);\n    var isResponderTouchEnd = responderInst && isEndish(topLevelType);\n    var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;\n\n    if (incrementalTouch) {\n      var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);\n      gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(gesture);\n      extracted = accumulate(extracted, gesture);\n    }\n\n    var isResponderTerminate = responderInst && topLevelType === 'topTouchCancel';\n    var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);\n    var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;\n    if (finalTouch) {\n      var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);\n      finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;\n      accumulateDirectDispatches(finalEvent);\n      extracted = accumulate(extracted, finalEvent);\n      changeResponder(null);\n    }\n\n    var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;\n    if (ResponderEventPlugin.GlobalInteractionHandler && numberActiveTouches !== previousActiveTouches) {\n      ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);\n    }\n    previousActiveTouches = numberActiveTouches;\n\n    return extracted;\n  },\n\n  GlobalResponderHandler: null,\n  GlobalInteractionHandler: null,\n\n  injection: {\n    /**\n     * @param {{onChange: (ReactID, ReactID) => void} GlobalResponderHandler\n     * Object that handles any change in responder. Use this to inject\n     * integration with an existing touch handling system etc.\n     */\n    injectGlobalResponderHandler: function (GlobalResponderHandler) {\n      ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;\n    },\n\n    /**\n     * @param {{onChange: (numberActiveTouches) => void} GlobalInteractionHandler\n     * Object that handles any change in the number of active touches.\n     */\n    injectGlobalInteractionHandler: function (GlobalInteractionHandler) {\n      ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;\n    }\n  }\n};\n\n// This is used by react-native-web.\nvar injectComponentTree = injection.injectComponentTree;\n// Inject react-dom's ComponentTree into this module.\nvar ReactDOMComponentTree = ReactDOM.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactDOMComponentTree;\n\ninjectComponentTree(ReactDOMComponentTree);\n\nvar ReactDOMUnstableNativeDependencies = Object.freeze({\n\tinjectComponentTree: injectComponentTree,\n\tResponderEventPlugin: ResponderEventPlugin,\n\tResponderTouchHistoryStore: ResponderTouchHistoryStore\n});\n\nvar unstableNativeDependencies = ReactDOMUnstableNativeDependencies;\n\nmodule.exports = unstableNativeDependencies;\n  })();\n}\n"]}